### Strony 196-239
## 31. Modelowanie bazy danych - rodzaje połączeń relacyjnych, pojęcie klucza głównego i obcego.

<a href="<link_to_resource_local_or_)nline_here>"></a><b></b>
**Klucz potencjalny** - minimalny zestaw atrybutów relacji, jednoznacznie identyfikujący każdą krotkę tej relacji. W relacji
może znajdować się wiele kluczy potencjalnych (zwanych czasem **kandydującymi**). Spośród kluczy potencjalnych
wybiera się zazwyczaj jeden klucz, zwany kluczem głównym.

**Klucz główny** (primary key) – wybrany minimalny zestaw atrybutów relacji, jednoznacznie identyfikujący każdy rekord
tej relacji. To oznacza, że taki klucz musi przyjmować **wyłącznie** wartości niepowtarzalne i nie może być wartością
pustą (null). Ponadto każda relacja może mieć najwyżej **jeden** klucz główny.<br>
Kluczem głównym może być dowolny klucz potencjalny, ale często stosuje się rozwiązanie polegające na utworzeniu
specjalnego atrybutu, którego wartości domyślne pobierane są z sekwencji (tzw. autonumeracja), tak aby zapewnić
unikalność klucza.

**Klucz obcy** - kombinacja jednego lub wielu atrybutów tabeli, które wyrażają się w dwóch lub większej liczbie relacji
(tabel). Wykorzystuje się go do tworzenia powiązania pomiędzy parą tabel, gdzie w jednej tabeli ten zbiór atrybutów jest
kluczem obcym, a w drugiej kluczem głównym.

### Związek 1:1 (jeden do jednego)
![alt text](http://www.sqlpedia.pl/wp-content/uploads/2013/04/Relacja_1_to_1_01.png)

### Relacja 1:N (jeden do wielu)
![alt text](http://www.sqlpedia.pl/wp-content/uploads/2013/04/Relacja_1_to_N_01.png)

### Relacja N:N (wiele do wielu)
![alt text](http://www.sqlpedia.pl/wp-content/uploads/2013/04/Relacja_wiele_do_wiele_01.png)


## 32. Pojęcie indeksu - rodzaje i zastosowanie.

Indeksowanie jest podstawowym mechanizmem wykorzystywanym w celu optymalizacji baz
danych SQL. Gdyby porównać bazę danych do książki, indeksy są czymś w rodzaju spisu treści.

Z technicznego punktu widzenia (i mocno uogólniając) indeksy to zbiór wartości typu „klucz –
lokalizacja”. Dzięki temu, na podstawie konkretnego klucza czyli parametrów zapytania jest
możliwe bardzo szybkie zwrócenie odpowiednich danych.

Klucze w indeksie przechowywane są w strukturze zwanej B-Tree (nie należy mylić tej
struktury danych z drzewem binarnym). B-Tree pozwala mechanizmom SQL Server znaleźć
pożądany rekord szybciej i wydajniej, ale tylko wtedy, gdy wyszukiwanie w tym drzewie
odbywa się za pomocą klucza.

B-drzewo i Drzewo binarne to typy nieliniowej struktury danych. Chociaż warunki wydają się
być podobne, ale różnią się pod każdym względem.

Drzewo binarne jest używane, gdy rekordy lub dane są przechowywane w pamięci RAM zamiast
na dysku, ponieważ prędkość dostępu do pamięci RAM jest znacznie większa niż na dysku. Z
drugiej strony B-tree jest używane, gdy dane są przechowywane na dysku, skraca czas dostępu,
zmniejszając wysokość drzewa i zwiększając gałęzie w węźle.  

![alt text](https://techdifferences.com/wp-content/uploads/2017/10/Untitled-7.jpg)

Problem z przeszukiwaniem baz danych polega na tym, że tabele nie są posortowane. Jedyna „kolejność” to często klucz

główny PRIMARY_KEY. Nie jest to przydatna kolejność kiedy szukamy danych nie po kluczu a po jakimś innym polu np:
SELECT nazwa_produktu FROM produkty WHERE cena = 128;

W przypadku kiedy dane są posortowane po kluczu głównym trzeba „sprawdzić” wszystkie rekordy i nie mamy
możliwości ułatwienia sobie zadania bo produkty mogą mieć przecież różną cenę. Mówi wtedy że dokonujemy pełnego
skanu tabeli, który działa niekorzystnie na wydajność. Indeksowania polega na unikaniu tego pełnego skanu.

### Jak działają indeksy?
Indeks jest uporządkowanym plikiem rekordów indeksu o stałej długości. Rekordy indeksu zawierają dwa pola: klucz
reprezentujący jedną z wartości występujących w atrybutach indeksowych relacji oraz wskaźnik do bloku danych
zawierający krotkę, której atrybut indeksowy równy jest kluczowi.

### Jak np.MySQL używa indeksów
- szybko znajduje wiersze pasujące do klauzuli
- ignoruje pewne wiersze (jeżeli MySQL ma do dyspozycji wiele indeksów używa tego najmniejszego) co przyspiesza skanowanie,
- szybciej zwraca zapytania w przypadku złączania wielu tabel,
- szybciej zwraca zapytania MIN() i MAX()

### Jakie kolumny i tabele należy indeksować
Korzyść wydajnościowa ze stosowania indeksów jest największa w przypadku dużych tabel (zawierających najwięcej
rekordów) oraz zapytań, które wykonywane są najczęściej.

W MySQL zaleca się indeksować następujące kolumny:
-kolumny najczęściej padające po słowie WHERE,
- kolumny dwóch tabel, które często łączymy,
- kolumny, według których sortujemy dane w raportach (kolumny padające po słowie ORDER BY i GROUP BY),
- kolumny które często zliczamy (SUM(), AVG(), MIN(), MAX(), COUNT())
- klucze obce i kolumny, których będziemy używać tak jak kluczy obcych,
- klucze niepowtarzalne UNIQUE_KEY (typu NIP, PESEL itd...),

### Nadmiar indeksów

Należy pamiętać, że indeks drastycznie **spowalnia dodawanie, modyfikowanie i usuwanie danych**, ponieważ indeksy muszą
być aktualizowane za każdym razem, gdy tabela ulega nawet najmniejszej modyfikacji. Najlepszą praktyką jest dodanie
indeksu dla wartości, które są **często używane do wyszukiwania, ale nie ulegają częstym zmianom.**

### Rodzaje indeksów 
- Indeks pogrupowany (clustered)

W jednej tabeli możemy posiadać tylko jeden index klastrowany dla jednej lub wielu kolumn. Założenie takiego indexu
równa się fizycznemu posortowaniu danych na dysku, w związku z tym niemożliwe jest założenie dwóch tego rodzaju
indexów.

Odczyt danych z tabeli która nie jest jest posortowana w przypadku gdy posiada setki tysięcy bądź miliony rekordów jest
bardzo czasochłonne. Serwer bazodanowy musi przejść rekord po rekordzie, by zwrócić dane o które prosimy. W związku z
tym należy założyć index, na przynajmniej jedną kolumnę aby usprawnić proces ‚poszukiwania’ rekordów.

> **CREATE CLUSTERED INDEX** nazwaIndeksu **ON** nazwaTabeli(nazwaKolumny);

Index klastrowany może być tylko jeden, ale może zostać założony na więcej niż jedną kolumnę

> **CREATE CLUSTERED INDEX** IX_EmployeesAgeFullName **ON** Employees(Age,FullName);

Nasza tabela została posortowana najpierw po kolumnie Age a następnie po kolumnie FullName
<br><br>

- Indeks niepogrupowany (non clustered)

Są swego rodzaju kopią danych, kopią kolumny na którą został założony taki index. Możemy posiadać więcej niż jeden index
non-clustred, jednak warto wiedzieć, że podczas zapisu danych do tabeli, jeśli dane wymagają ponownego posortowania, to
operacja zapisu będzię trwać dłużej. Im więcej indexów, tym dłuższy czas oczekiwania na ukończenie operacji. Tego typu
index jest również wolniejszy jeżeli odpytujemy o więcej danych, niż zostało to zadeklarowane na początku.
> **CREATE NONCLUSTERED INDEX** nazwaIndexu **ON** nazwaTablicy(nazwaKolumny);


## 33. Podstawowe konstrukcje języka SQL.

### Cechy języka SQL
- Język wysokiego poziomu
- Jest językiem deklaratywnym, zorientowanym na wynik
- Jest oparty na algebrze relacji
- Zawiera logikę trójwartościową
- Nie posiada instrukcji sterujących wykonywaniem programu
- Nie dopuszcza rekurencji
- Umożliwia definiowanie struktur danych, wyszukiwanie danych oraz operacje na danych
- Działa na zbiorach danych
  
### Struktura i wykorzystanie języka SQL
- Język SQL jest przykładem języka transformacji, co oznacza, że został on tak zaprojektowany, że
umożliwia przekształcenie relacji wejściowych na relację wyjściową.
- Jest językiem nieproceduralnym, w którym użytkownik opisuje informację, której potrzebuje, ale nie
wskazuje on przy tym, w jaki sposób należy ją odnaleźć.
- Zapytanie języka SQL składa się ze słów zarezerwowanych oraz ze słów zdefiniowanych przez samego
użytkownika. Należy je zapisywać w sposóbdokładny, bez jakichkolwiek zmian, tj. dokładnie tak jak
wymaga tego składnia języka SQL.
- Każde zapytanie w języku SQL jest kończone średnikiem.

### Komponenty języka SQL
- **DDL (Data Definition Language)** – język definiowania struktur danych
(CREATE, DROP, ALTER TABLE).
- **DML (Data Manipulation Language)** – język operacji na danych (SELECT, INSERT, UPDATE, DELETE).
- **Instrukcje sterowania danymi** – kontrola uprawnień użytkowników (GRANT, REVOKE).

### Tabele w języku SQL

Do manipulowania tabelkami używa się kilku poleceń:

- **CREATE TABLE** – definiuje tabelę i jej kolumny,
- **ALTER TABLE** – zmienia tabele i kolumny,
- **DROP TABLE** – usuwa tabelę – jej definicję i zawartość,
- **RENAME** – zmienia nazwę tabeli

Polecenia **CREATE TABLE** i **ALTER TABLE** są ponadto używane w celu definiowania ograniczeń kluczy oraz
tzw. parametrów przechowywania, które są rozszerzeniami składni Oracle.

### Typy danych // Typy tekstowe

- **VARCHAR2(L)** – oznacza typ danych, za pomocą którego można przechowywać ciągi znaków o
zmiennej długości, gdzie L oznacza określoną maksymalną długość zmiennej tego typu. Dopuszczalny
rozmiar dla zmiennej VARCHAR2 wynosi 4000 bajtów.
- **VARCHAR(L)** – pozwala przechowywać napisy o zmiennej długości, których długość może wahać się
od 1 do 2000 znaków.
- **CHAR(L)** – pozwala przechowywać ciągi znaków o stałej długości wskazanej w parametrze rozmiar.
Maksymalna wielkość to 2000 bajtów. Długość domyślna to 1 znak. Ciągi są dopełniane z prawej strony
spacjami do pełnej wielkości pola.

### Typy numeryczne

- **NUMBER(zakres)** – typ całkowity – pozwala przechowywać liczby całkowite ze znakiem mającą tyle
cyfr, ile wynosi parametr zakres (o maksymalnej długości 38 cyfr).
- **NUMBER(zakres, dokładność)** – określa dziesiętną liczbę stałoprzecinkową zapisywaną z dokładnością
do maksymalnie 38 cyfr i wykładnikiem pomiędzy -84 a 127.
- **NUMBER** – określa kolumnę zmiennoprzecinkową z 38 cyframi pamiętanymi dokładnie i wykładnikiem
pomiędzy 125 a -127.

### Typ czasu

- **DATE** – obejmuje okres od pierwszego stycznia 4712 r. p.n.e. do 31 grudnia 4712 r. n.e. 
<br> Kolumna typu
DATE może przechowywać czas z dokładnością do sekund.

### Operacje DDL
Tworzenie nowej tabeli
**CREATE TABLE** *nazwa_tabeli (nazwa_kolumny1 typ_danych1)*;

``` CREATE TABLE towary (
nr_towar NUMBER(4),
nazwa VARCHAR2(15),
cena NUMBER(7,2),
kategoria VARCHAR2(30),
stan_magazyn NUMBER,
wycofany CHAR(3) );
 ```

### Wartość NOT NULL i wartość domyślna

- Wartość NOT NULL dla pola
By w danym polu tabeli nie mogła wystąpić wartość pusta należy po
zdefiniowaniu typu danych pola podać wyrażenie NOT NULL.
Wyrażenie NOT NULL wskazuje właśnie, iż kolumna ta nie zaakceptuje
wartości pustej NULL.
- W celu ustawienia dla kolumny tabeli wartości domyślnej należy użyć
słowa kluczowego DEFAULT, po którym podajemy wartość domyślną.
Wartość domyślna może być stałą bądź pseudofunkcją.

```
CREATE TABLE towary (
nr_towar NUMBER(4),
nazwa VARCHAR2(15),
cena NUMBER(7,2),
kategoria VARCHAR2(30),
stan_magazyn NUMBER,
wycofany CHAR(3) );
```
### Sposoby usuwania tabel i ich zawartości
Tabele i ich zawartość są usuwane za pomocą polecenia DROP TABLE
nazwa_tabeli. Dla tabel, do których nie odwołuje się żaden klucz obcy, tabela i jej zawartość zostanie całkowicie usunięta.

- **DROP TABLE** czytelnicy;
- Gdy usuwana tabela jest połączona więzami referencyjnymi (integralności) z innymi tabelami, należy użyć
polecenia **DROP TABLE** nazwa_tabeli **CASCADE CONSTRAINTS**.
> Przykład: **DROP TABLE** czytelnicy **CASCADE CONSTRAINTS**;
- W celu natychmiastowego i bezpowrotnego usunięcia zawartości tabeli należy użyć polecenia TRUNCATE TABLE
nazwa_tabeli. Polecenie TRUNCATE TABLE czyści zawartość tabeli bezpowrotnie (ale nie usuwa jej fizycznie),
ponieważ mechanizm anulowania jest nieaktywny.
>Przykład: **TRUNCATE TABLE** towary;

### Zmiana nazwy tabeli i dodawanie kolumny do tabeli
- Zmiana nazwy tabeli:
<br>**RENAME** stara_nazwa_tabeli **TO** nowa_nazwa_tabeli;
- Dodawanie kolumny do tabeli
Dodawanie kolumn jest wykonywane za pomocą opcji **ADD** polecenia **ALTER TABLE**. 
<br>**ALTER TABLE** nazwa_tabeli **ADD** (nazwa_kolumny typ_kolumny);


### Zmiana definicji kolumny tabeli

Z pewnymi ograniczeniami, przy użyciu opcji **MODIFY** polecenia **ALTER TABLE** można zmienić cztery części
definicji kolumny:
- Kolumna może być zmieniona na dowolny prawidłowy typ danych, jeśli nie jest wypełniona w tym
znaczeniu, że każdy wiersz musi zawierać wartość **NULL** w tej kolumnie. W innym przypadku kolumna
typu **VARCHAR2** może być zmieniona na **CHAR** tego samego rozmiaru i na odwrót.
- Kolumna, która nie jest wypełniona danymi, może być zmieniona na dowolny prawidłowy wymiar.
Rozmiar i precyzja kolumny już wypełnionej danymi nie może ulec zmniejszeniu.
- Ograniczenia **NOT NULL** mogą być dodane, jeśli ani jeden wiersz nie posiada ograniczenia **NULL** w tej
kolumnie. Ograniczenia **NOT NULL** mogą być również usuwane.
- Można zmieniać wartości domyślne.
>Przykład: **ALTER TABLE** towary **MODIFY** (kategoria **VARCHAR(30)** **NOT NULL**);

Usunięcie **kolumny** z **tabeli**:
>Przykład: **ALTER TABLE** nazwa_tabeli **DROP COLUMN** nazwa_kolumny;

### Ograniczenia tabel/kolumn
Ograniczenia, jakie można ustawić dla tabel/kolumn służą następującym celom:
- Ograniczają wartości, które mogłyby zostać wstawione do kolumny lub zestawu kolumn.
- Przyśpieszają lub mogą przyśpieszać pobieranie pojedynczych wierszy lub zestawów wierszy.

Ograniczenia mogą być:
1. **Statyczne**, które limitują wartość lub zakres wartości, które mogą być wstawione (np. **CHECK**, **NOT NULL**),
2. **Dynamiczne**, w relacji ze wszystkimi wartościami kolumny, ograniczając w ten sposób nowe wartości tylko do takich
wartości, które nie występują w pewnych kolumnach lub zestawach kolumn (klucz unikalny, klucz podstawowy).
3. **Dynamiczne**, w relacji z inną tabelą, pozwalając w ten sposób na wstawienie jedynie takich wartości, które występują
także w innych kolumnach w innej (lub tej samej) tabeli (klucz obcy).
4. **Indeksami** – przyśpieszają one pobieranie danych. Ponadto indeksy tabeli są używane także w celu zapewnienia unikalnej
wartości w kolumnie unikalnego lub podstawowego klucza.

### Ograniczenia CHECK
Istnieje kilka możliwości wykorzystania ograniczenia **CHECK**:
- **kolumny wymagane** – zapobiega wprowadzaniu wartości niezidentyfikowanych do tych pól,
- **prawidłowe zakresy** – możliwość ograniczenia wprowadzanych wartości od określonych zakresów,
- **zakresy kodów** – możliwość ustawienia odpowiedniej struktury jednoznacznych kodów,
- **reguły biznesowe** – określenie pewnych reguł i wymuszenie pewnych zależności.

Ograniczenie **CHECK** jest definiowane:
- przy użyciu podklauzuli **CHECK**(warunek)
- w poleceniu **CREATE TABLE** lub w poleceniu **ALTER TABLE** nazwa_tabeli **ADD**.

Przykład:
```
CREATE TABLE drużyny_pilkarskie (
nr_druzyny NUMBER(4) NOT NULL,
nazwa VARCHAR2(30) NOT NULL,
liczba_goli NUMBER NOT NULL,
liczba_goli_dom NUMBER CHECK(liczba_goli_dom <= liczba_goli), liczba_goli_wyjazd
NUMBER CHECK(liczba_goli_wyjazd <= liczba_goli) );
```
Nazywanie ograniczeń
Jeśli w tabeli wprowadzamy ograniczenia bez podawania ich nazw, wówczas system sam nadaje każdemu
ograniczeniu unikalną nazwę, która jest przechowywana w przestrzeni nazw.


Dla przykładu utwórzmy tabelę towary nazywając ograniczenia:
```
CREATE TABLE towary (
nr_towar NUMBER(4),
nazwa VARCHAR2(15) CONSTRAINT nazwa_nn NOT NULL,
cena NUMBER(7,2) CONSTRAINT cena_nn NOT NULL,
kategoria VARCHAR2(30) CONSTRAINT kategoria_nn NOT NULL, stan_magazyn
NUMBER DEFAULT 0,
wycofany CHAR(3) DEFAULT ‘Nie’,
CONSTRAINT towary_pk PRIMARY KEY(nr_towar),
CONSTRAINT wycofany_CH CHECK(wycofany IN ('Tak', 'Nie')));
```

### Operacje DML
W języku **SQL** poleceniami służącymi do modyfikowania danych w tabelach są jedynie trzy operacje, które
zaliczamy do operacji **DML**:
- wstawianie nowego wiersza do tabeli,
- usuwanie wierszy z tabeli,
- aktualizowanie kolumn w tabeli.
### Polecenie **INSERT**
Za pomocą polecenia **INSERT** można:
- utworzyć nowy wiersz w tabeli bazy danych,
- załadować wyszczególnione wartości do wszystkich lub wskazanych kolumn do wskazanej tabeli.
- 
Składnia:
- **INSERT INTO** nazwa_tabeli (nazwa_pola1, nazwa_pola2, ...,
nazwa_polaN) VALUES (wartość1, wartość2, ..., wartośćN);
- **INSERT INTO** nazwa_tabeli VALUES (wartość1, wartość2, ..., wartośćN);

Przykład:
> **INSERT INTO** towary (nr_towar, nazwa, cena, nazwa_kategorii, stan
magazynu) **VALUES** (104, 'chleb', 2.20, 'pieczywo',100);

### Usuwanie wierszy – **DELETE i TRUNCATE**
Składnia DELETE:
>**DELETE FROM** nazwa_tabeli **WHERE** warunek_logiczny;
```
Przykład:
DELETE FROM towarywycofane
WHERE nr_towar IN (SELECT nr_towar
FROM towary WHERE stan = 0);
```
Polecenie **TRUNCATE TABLE** *nazwa_tabeli*  przyśpiesza proces usuwania dzięki temu, że nie zapisuje informacji sprzed
modyfikacji do przestrzeni wycofania. Ten fakt powoduje jednak, iż nie jest możliwe przywrócenie usuniętych
danych. To polecenie nie zawiera także klauzuli **WHERE**, a zatem zawsze usuwa wszystkie wiersze wskazanej tabeli.

### Polecenie **UPDATE**
Polecenie UPDATE dotyczące aktualizacji danych różni się od pozostałych dwóch operacji DML dotyczących
modyfikacji danych w tabelach, ponieważ nie ma wpływu na liczbę wierszy w tabeli.

Składnia:
```
UPDATE nazwa_tabeli
SET lista
WHERE warunek;
```
gdzie:
- **nazwa_tabeli** – wskazuje tabelę, w której przechowywane dane mają zostać zaktualizowane,
- **lista** – wykaz kolumn, które mają zostać zaktualizowane oraz lista wartości, jakie będą przypisane tym
kolumnom,
- **warunek** – warunek logiczny, którego spełnienie powoduje, iż dany wiersz dla którego jest spełniony będzie
aktualizowany.

Polecenie UPDATE - przykład
>**UPDATE** towary **SET** nazwa = ‘czekolada mleczna’, cena = 2.50 **WHERE** nr_towar = 1;

### Instrukcja **SELECT**
Podstawową, najczęściej używaną instrukcją języka SQL jest instrukcja **SELECT**, która służy do pobierania
danych z jednej tabeli lub większej liczby tabel
(widoków). Niezależnie od liczby tabel i/lub widoków oraz niezależnie od rodzaju operacji
wykonywanych na zbiorach lub pseudozbiorach, zawsze jako wynik otrzymujemy wirtualną pojedynczą
tabelę (tzw. dynamiczny zestaw wyników), którą dalej możemy przetwarzać.

Składnia:
>**SELECT** lista_kolumn
**FROM** lista_tabel;

Pobranie wszystkich wierszy i wszystkich kolumn:
> **SELECT** * **FROM** towary;

Pobieranie wszystkich wierszy i wybranych kolumn:
>**SELECT** nazwa, cena
**FROM** towary;

### Listy przecinkowe
W języku SQL listy przecinkowe są wykorzystywane w różnych celach:
- lista przecinkowa frazy **SELECT** określa, które kolumny mają być wybrane w zapytaniu,
- lista przecinkowa frazy **FROM** podaje tabele, z których dane mają być wybrane,
- lista przecinkowa frazy **GROUP** BY jest używana do agregowania danych w grupach wg podanych
kolumn,
- lista przecinkowa frazy **ORDER BY** pozwala ustalić kryteria sortowania danych,
- lista przecinkowa jest wykorzystywana w instrukcji **IN**.
  
### Aliasy
Istotna odmiana listy przecinkowej powstaje w wyniku tzw. aliasingu, czyli nadawania **aliasów**
(„pseudonimów”) dla tych elementów, które bezpośrednio poprzedzają alias. Jeśli alias jest umieszczony za
określanym elementem, to do tego elementu można odwołać się zarówno poprzez jego nazwę lub alias
(**poza pewnymi przypadkami**, kiedy można odwołać się tylko za pomocą nazwy oraz pewnymi
przypadkami, kiedy można odwołać się tylko za pomocą aliasu).

Przykład (nadanie zastępczych aliasów dwóm wyświetlanym kolumnom):
```
SELECT nazwa nazwa_towaru, cena cena_jednostkowa
FROM towary;
```
### Klauzula ORDER BY

Klauzula **ORDER BY** instrukcji **SELECT** służy do sortowania danych w języku SQL. Sortowanie danych można
wykonać na dwa sposoby: albo w porządku rosnącym (ustawienie domyślne) – opcja **ASC** lub w
porządku malejącym wartości kolumny użytej do sortowania – opcja **DESC**.

Przykład:
```
SELECT nr_towar, nazwa, cena, stan, towary
FROM towary
ORDER BY cena DESC;
```

## 34. Warstwy i funkcje modelu ISO OSI.
### PO CO NAM MODELE?

- Zanim dane z urządzenia źródłowego zostaną przesłane do urządzenia
końcowego muszą przejść długą drogę, podczas której najpierw są odpowiednio
oznaczane, tagowane, opisywane określonymi informacjami pozwalającymi na
ich identyfikację, potem przesyłane są pomiędzy wieloma urządzeniami
pośredniczącymi, aż trafią do odbiorcy, który dane to potem musi
zinterpretować.

- Gdyby nie istniał taki model, który dzieli komunikację na mniejsze, łatwiejsze do
zrozumienia i zarządzania etapy oraz określa zadania, jakie muszą być
realizowane w poszczególnych warstwach trudno byłoby we właściwy sposób
zarządzać komunikacją sieciową ponieważ mnogość rozwiązań i technologii
powodowałaby olbrzymi chaos, trudny do opanowania.

### Model ISO/OSI składa się z 7 warstw:

- **Warstwa 7:** **aplikacji** - Udostępnia użytkownikom możliwość
korzystania z usług sieciowych, takich jak WWW, poczta
elektroniczna, wymiana plików, połączenia terminalowe czy
komunikatory.

- **Warstwa 6:** **prezentacji** - Przekazuje do warstwy aplikacji
informacje o zastosowanym formacie danych, np. informuje
jakie typy plików będą przesyłane, odpowiada ona również za
odpowiednie zakodowanie danych na urządzeniu źródłowym i
ich dekodowanie na urządzeniu docelowym.

- **Warstwa 5:** **sesji** - Warstwa sesji otrzymuje od różnych
aplikacji dane, które muszą zostać odpowiednio
zsynchronizowane. Synchronizacja występuje między
warstwami sesji systemu nadawcy i odbiorcy. Warstwa sesji
„wie”, która aplikacja łączy się z którą, dzięki czemu może
zapewnić właściwy kierunek przepływu danych –nadzoruje
połączenie. Wznawia je po przerwaniu.

- **Warstwa 4:** **transportu** - Głównym zadaniem jest sprawna obsługa komunikacji
pomiędzy urządzeniami. W warstwie tej dane dzielone są na mniejsze części,
następnie opatrywane są dodatkowymi informacjami pozwalającymi zarówno
przydzielić je do właściwej aplikacji na urządzeniu docelowym, jak i pozwalającymi
złożyć je na urządzeniu docelowym w odpowiedniej kolejności.

- **Warstwa 3:** **sieci** - Warstwa sieciowa jako jedyna dysponuje wiedzą dotyczącą
fizycznej topologii sieci. Rozpoznaje, jakie drogi łączą poszczególne komputery
(trasowanie) i decyduje, ile informacji należy przesłać jednym z połączeń, a ile
innym. Jeżeli danych do przesłania jest zbyt wiele, to warstwa sieciowa po prostu
je ignoruje.

- **Warstwa 2:** **łącza danych** - Głównym zadaniem jest kontrola dostępu do medium
transmisyjnego, a także adresowanie danych, tym razem jednak w celu
przesyłania ich pomiędzy hostami w sieci LAN.

- **Warstwa 1:** **fizyczna** - Koduje dane do postaci czystych bitów (zer i jedynek) i
przesyła je poprzez medium transmisyjne do odpowiednich urządzeń.


![alt text](https://pasja-informatyki.pl/pliki/model-iso-osi.jpg)


## 35. Adresowanie logiczne w sieciach komputerowych.
### Adresowanie logiczne // Różnice
- Adresowanie **fizyczne** (inaczej sprzętowe) polega na tym że adres fizyczny jest „wypalonym” adresem MAC
w układzie ROM karty sieciowej
- Adresowanie **logiczne** z kolei działa w ten sposób, że każdy komputer w sieci ma unikatowy adres IP,
którego przydział jest administrowany przez odpowiednie organizacje
- Adresowanie **logiczne** występuje w trzeciej warstwie modelu odniesienia ISO/OSI, czyli w warstwie sieciowej,
oraz w warstwie internetowej w modelu TCP/IP.

### Adres IP
- Jest unikalny w skali globalnej (poza pewnymi specjalnymi przypadkami)
- Nie musi być jednoznacznie przypisany jednemu urządzeniu (interfejsowi sieciowemu): jeden interfejs może
mieć wiele adresów IP, jeden adres IP może przypisany wielu urządzeniom
- Jest 32-bitowy (4 bajty zwane „oktetami”) i zwykle jest zapisywany dziesiętnie
- Jest widoczny „dla użytkownika” w przeciwieństwie do adresu MAC

![alt text](resources/35-1.png)

### Podział adresów
- Klasa A: od 0.0.0.0 do 127.255.255.255
- Klasa B: od 128.0.0.0 do 191.255.255.255
- Klasa C: od 192.0.0.0 do 223.255.255.255
- Klasa D: od 224.0.0.0 do 239.255.255.255
- Klasa E: od 240.0.0.0 do 255.255.255.255

### Maska sieci
- Jest adresem IP służącym do sprawdzania czy dany adres
IP jest adresem z danej sieci, logicznego dzielenia sieci na
podsieci (od wyboru maski zależy maksymalna liczba
węzłów w danej podsieci) oraz określenia jaka część
adresu IP określa adres sieci a jaka adresy węzłów.

### Adres rozgłoszeniowy
- Ostatni adres z zakresu adresów IP
- Wszystkie bity służące do numerowania węzłów maja
wartość 1
- Jest wykorzystywany przez aplikacje sieciowe
zainstalowane na hostach do wysyłania sygnałów do
wszystkich użytkowników (węzłów) danej sieci.

### Aby skonfigurować protokół IP należy:
- wyznaczyć adres sieci
- wyznaczyć maskę sieci
- wyznaczyć adres rozgłoszeniowy
- określić sposób przydzielania adresów
- określić adres IP domyślnej bramy danej sieci
- określić adresy IP serwerów DNS

## 36. Najważniejsze protokoły rodziny TCP/IP.

**TCP/IP** (ang. Transmission Control Protocol/Internet Protocol) to zbiór protokołów służących
do transmisji danych przez sieci komputerowe. Model TCP/IP został stworzony w latach 70.
XX wieku w [DARPA](https://pl.wikipedia.org/wiki/Defense_Advanced_Research_Projects_Agency), aby pomóc w tworzeniu odpornych na atak sieci komputerowych. Potem
stał się podstawą struktury Internetu. Model TCP/IP implementuje najważniejsze
funkcjonalności siedmiu warstw standardowego modelu OSI. Poniższy schemat przedstawia
odpowiadające sobie warstwy modeli TCP/IP i OSI.

![alt text](https://pasja-informatyki.pl/pliki/porownanie-iso-osi.jpg)

Każda wiadomość wysłana przez aplikację przechodzi przez wszystkie warstwy TCP/IP, od
warstwy aplikacji do najniższej warstwy dostępu do sieci. Następnie jest transmitowana
przez sieć do drugiego komputera. Na koniec przechodzi przez wszystkie warstwy w
przeciwnym kierunku, aż do warstwy aplikacji i docelowego procesu.
Podczas przesyłania danych z aplikacji do sieci, każda warstwa dodaje swój własny nagłówek
do każdej wiadomości. Każdy z tych nagłówków jest potem odczytywany przez odpowiednią
warstwę w komputerze odbierającym wiadomość. Zarówno zawartość jak i wielkość
nagłówków zależą od użytych protokołów.


### **Wysyłanie wiadomości w TCP/IP**
![alt text](https://sites.google.com/site/atomowki99/_/rsrc/1518005763683/sieci-komputerowe/protokolu-modelu-tcp-ip/tcpip_flow_send_pl.png)


### **Odbieranie wiadomości w TCP/IP**
![alt text](https://sites.google.com/site/atomowki99/_/rsrc/1518005755123/sieci-komputerowe/protokolu-modelu-tcp-ip/tcpip_flow_receive_pl.png)

### WARSTWA APLIKACJI
Pośredniczy w komunikacji pomiędzy programami komputerowymi i protokołami niższych
warstw, umożliwiając w ten sposób aplikacjom korzystanie z sieci. Jest to warstwa najbliższa
użytkownikowi, ponieważ to właśnie ona pozwala nam w pełni korzystać z usług sieciowych.
Kiedy siadamy przed komputerem i uruchamiamy np. przeglądarkę internetową to
korzystamy z sieci właśnie na poziomie warstwy aplikacji.
Istnieje wiele protokołów warstwy aplikacji, które wykorzystują transmisję TCP/IP.
 ### Jednymi z ważniejszych protokołów warstwy aplikacji są:
- **HTTP, HTTPS** - do przeglądania stron www,
- **FTP, TFTP, NFS** - do transmisji plików,
- **SMTP** - do wysyłania wiadomości email,
- **POP3** - do otrzymywania wiadomości email,
- **IMAP** - do zarządzania wiadomościami email na serwerach,
- **Telnet**, **rLogin** - do zdalnego logowania się na innych komputerach,
- **SNMP** - do zarządzania sieciami komputerowymi,
- **DNS** - do znajdowania adresów IP przypisanych do adresów WWW,
- **IRC** - do czatów online

Budowa wiadomości warstwy aplikacji różni się w zależności od protokołu, który został użyty.
Każdy protokół może wymagać różnych danych wejściowych i produkować różne zapytania,
które będą wysłane do warstwy transportowej. Niezależnie od formy wiadomości utworzonej
przez warstwę aplikacji, warstwa transportowa traktuje każdą otrzymaną wiadomość
jako dane i nie wnika w ich zawartość.

### Gniazda sieciowe

Gniazda sieciowe to struktury, które są wykorzystywane podczas komunikacji pomiędzy
warstwami aplikacji i transportową. Każdy proces i aplikacja, który próbuje połączyć się z
siecią, musi powiązać swoje kanały transmisji danych wejściowych i wyjściowych poprzez
utworzenie właściwego obiektu gniazda sieciowego.

Obiekt gniazda sieciowego zawiera informacje o adresie IP, numerze portu i użytym protokole
warstwy transportowej. Unikalna kombinacja tych trzech parametrów pozwala na
zidentyfikowanie właściwego procesu, do którego wiadomość powinna być dostarczona.


Numer portu może zostać przypisany automatycznie przez system operacyjny, ręcznie przez
użytkownika lub może być mu przypisana wartość domyślna, właściwa pewnym popularnym
aplikacjom. Numer portu jest 16-bitową liczbą całkowitą (0 - 65535).


Niektóre popularne protokoły warstwy aplikacji używają domyślnych i publicznie znanych
numerów porów. Na przykład, HTTP używa portu 80, HTTPS używa portu 443, SMTP portu 25,
Telnet portu 23, natomiast FTP używa dwóch portów: 20 do transmisji danych i 21 kontroli
transmisji. Lista domyślnych numerów portów jest zarządzana przez organizację Internet
Assigned Numbers Authority.

### WARSTWA TRANSPORTOWA
Jej głównym zadaniem jest sprawna obsługa komunikacji pomiędzy urządzeniami. W warstwie
tej dane dzielone są na mniejsze części, następnie opatrywane są dodatkowymi informacjami
(nagłówki) pozwalającymi zarówno przydzielić je do właściwej aplikacji na urządzeniu
docelowym, jak i pozwalającymi złożyć je na urządzeniu docelowym w odpowiedniej
kolejności. Nagłówek zawiera szereg informacji kontrolnych, w szczególności numery portów
nadawcy i odbiorcy.

### TCP
Najpopularniejszym protokołem warstwy transportowej jest TCP (ang. Transmission Control
Protocol). Podczas transmisji danych, TCP zestawia połączenie pomiędzy komunikującymi się
stronami przez zainicjowanie tzw. sesji (ang. session). TCP jest protokołem niezawodnym, w
którym odbiorca potwierdza otrzymanie każdej wiadomości. Wszystkie wiadomości
dostarczane są w takiej samej kolejności, w jakiej zostały wysłane.
Wszystkie cechy wymienione powyżej są zapewniane przez warstwę TCP. Oznacza to, że TCP
może współdziałać z innymi, bardziej zawodnymi protokołami niższych warstw i nie powinno
to afektować komunikacji z perspektywy warstwy aplikacji.
### Niezawodność. 
Odbiorca testuje każdy otrzymany pakiet pod kątem błędów transmisji
(poprzez wyliczanie sumy kontrolnej danych). Jeśli wiadomość jest poprawna, odbiorca wysyła
potwierdzenie do nadawcy. Jeśli nadawca nie otrzyma potwierdzenia w przeciągu
określonego (konfigurowalnego) czasu, to ponownie wysyła zagubiony pakiet.
Po kilku nieudanych próbach, TCP zakłada, że odbiorca jest nieosiągalny i informuje warstwę
aplikacji, że transmisja zakończyła się niepowodzeniem.

### Uszeregowanie pakietów w TCP.
Jedno z pól nagłówka TCP zawiera numer sekwencyjny
wiadomości. Numer sekwencyjny jest zwiększany o jeden dla każdej wysłanej wiadomości.
Podczas odbierania wiadomości, TCP układa pakiety we właściwej kolejności. Dzięki temu,
warstwa aplikacji nie musi w ogóle zajmować się kolejnością przychodzących pakietów
sieciowych.
### Nagłówek TCP
Składa się z 20 lub więcej bajtów. Dokładna wielkość zależy od tego czy
opcjonalne pole opcji jest używane. Maksymalna wielkość tego pola to 40 bajtów, więc
maksymalna wielkość całego nagłówka to 60 bajtów.

![alt text](https://slideplayer.pl/slide/417583/1/images/61/TCP+Opis+nag%C5%82%C3%B3wka+TCP..jpg)

### Sesja **TCP**.
W celu wymiany danych przy pomocy TCP, dwie aplikacje muszą najpierw
zainicjować sesję.
<br>TCP wymaga wymiany trzech wiadomości żeby utworzyć sesję:

1. SYN - pierwsza aplikacja (klient) wysyła pakiet synchronize do serwera. Wiadomość
zawiera losowy numer sekwencyjny, który został wybrany przez klienta.
2. SYN-ACK - serwer odpowiada do klienta. Otrzymany numer sekwencyjny jest
zwiększany o jeden i załączany do odpowiedzi jako numer potwierdzenia.
Dodatkowo, odpowiedź zawiera inny numer sekwencyjny, losowo wybrany przez
serwer.
3. ACK - klient potwierdza otrzymanie odpowiedzi od serwera. Wiadomość zawiera oba
otrzymane numery zwiększone o jeden.


Kiedy transmisja pomiędzy klientem i serwerem zostanie zakończona, sesja powinna zostać
zamknięta. Każda strona komunikacji może zakończyć trwającą sesję. Druga strona powinna
odpowiedzieć na to, wysyłając odpowiednie potwierdzenie.


Zastosowanie TCP. TCP jest szeroko wykorzystywane w protokołach i aplikacjach, które
wymagają wysokiej niezawodności. Można wymienić wiele protokołów warstwy aplikacji,
które używane są głównie razem z TCP. 

Jednymi z najpopularniejszych są:
- HTTP, HTTPS
- FTP
- SMTP
- Telnet

### **UDP**
Drugim popularnym protokołem używanym w warstwie transportowej jest **UDP**
*(ang. User
Datagram Protocol lub Universal Datagram Protocol).* Jest to prostszy protokół, w którym
komunikacja odbywa się bez nawiązywania żadnego stałego połączenia pomiędzy aplikacjami.
Wszystkie pakiety wysyłane są niezależnie od siebie.
Dzięki swojej prostocie **UDP** jest szybsze niż **TCP**. Z drugiej jednak strony, nie zapewnia takiej
niezawodności działania jak **TCP**, nie gwarantuje, że wiadomości rzeczywiście dotarły
do odbiorcy. **UDP** nie dostarcza pakietów w takiej samej kolejności, w jakiej zostały one
wysłane. Ciężar uporządkowania otrzymywanych wiadomości i sprawdzenia czy nie nastąpiły
błędy transmisji spoczywa na otrzymującej je aplikacji.
### Nagłówek **UPD**
Składa się z 8 bajtów, jest więc znacznie krótszy niż odpowiadający mu
nagłówek **TCP**.

![alt text](https://slideplayer.pl/slide/417583/1/images/65/UDP+Struktura+nag%C5%82%C3%B3wka+UDP.jpg)

<br><br>
### Zastosowanie **UDP**.
**UDP** jest preferowane jeśli przesyłane pakiety danych są nieistotne lub
komunikacja musi odbywać się z wyjątkowo dużą prędkością czyli np. podczas transmisji audio
i video, gdzie utrata pewnej liczby pakietów nie jest bardzo uciążliwa dla odbiorcy.
Istnieje wiele protokołów warstwy aplikacji, które używają UDP, na przykład:
- **DNS**
- **DHCP** - umożliwia podłączonym do sieci komputerom pobieranie adresu IP,
maski podsieci, adresu bramy i serwera DNS itp.
- **TFTP**
- **SNMP**
- **RIP** - protokół bram wewnętrznych oparty na zestawie algorytmów
wektorowych, służących do obliczania najlepszej trasy do celu
- **VOIP** – telefonia internetowa
  
### DCCP
*Datagram Congestion Control Protocol* jest protokołem, który umożliwia aplikacjom
kontrolowanie przepływu danych w celu zapobiegania przeciążeniom sieci i utrzymywania
stabilnych połączeń. **DCCP** nie zapewnia niezawodnej komunikacji z zachowaniem kolejności
wysyłanych pakietów.
<br>
**DCCP** jest wykorzystywany przez aplikacje, które operują na szybko zmieniających się
danych (dane audio i video, gry online, VoIP). W takich sytuacjach często preferuje się użycie
nowej porcji dostępnych danych, zamiast proszenia o retransmitowanie starego
uszkodzonego pakietu.

### RSVP
*Resource Reservati)n Protocol* umożliwia zdalne rezerwowanie zasobów przy użyciu sieci
komputerowych. Jest używany głównie przez routery i serwery w celu zapewnienia usług
o określonej jakości dla klientów.
<br>
**RSVP** jest w stanie rezerwować pasma transmisji dla komunikacji pomiędzy dwoma
komputerami oraz pomiędzy jednym serwerem i wieloma klientami. Wymiana wiadomości w
ramach **RSVP** jest inicjowana przez klienta (odbiorcę), który prosi router (serwer)
o zarezerwowanie zasobów.

### SCTP
*Stream Control Transmission Protocol* umożliwia przesyłanie wielu strumieni danych
spakowanych razem w pojedynczym strumieniu. Podobnie jak **TCP**, **SCTP** zapewnia
niezawodną transmisję z zachowaniem kolejności pakietów i zapobieganiem przeciążeniom,
dodatkowo rozbudowując jego funkcjonalności o umieszczanie pokrewnych strumieni danych
w tych samych wiadomościach.
<br>
Ogólnie rzecz biorąc **SCTP**, jest bardzo rozbudowanym protokołem zapewniającym
dobrą jakość komunikacji. Niestety, z racji braku wspierania tego protokołu przez
najpopularniejsze routery i systemy operacyjne, nie jest on popularny i szerzej używany.

### WARSTWA INTERNETU
Głównym zadaniem jest odnalezienie najkrótszej i najszybszej drogi do urządzenia docelowego
przez sieć rozległą, podobnie jak robią to samochodowe GPS’y, ale także adresowanie danych
z wykorzystaniem adresów logicznych (**adresów IP**). Adres IP jest unikalnym wirtualnym
numerem, który umożliwia znajdowanie urządzenia w sieci.
Istnieje kilka popularnych protokołów, które działają w warstwie internetowej.
Najpopularniejszym i najważniejszym z nich jest IP (Internet Protocol), ale warto wymienić też


Inne protokoły warstwy internetowej:
- **ARP** (Address Resolution Protocol)
- **RARP** (Reverse Address Resolution Protocol)
- **ICMP** (Internet Control Message Protocol)

### IP
**IP** służy do przesyłania pakietów danych przez sieć. Obecnie używane są dwie wersje tego
protokołu, **IPv4** i **IPv6.**


IP nie zapewnia żadnego systemu potwierdzania dostarczenia wiadomości, co oznacza, że nie
jest niezawodnym protokołem. Obowiązek upewniania się, że wszystkie dane zostały
dostarczone spoczywa na protokole TCP operującym w warstwie transportowej. Całe
połączenie TCP/IP jest więc niezawodne.

### Datagramy IP
Pakiety danych otrzymywane z warstwy transportowej są dzielone na mniejsze datagramy.
Każdy datagram zawiera nagłówek IP oraz bajty otrzymane z warstwy transportowej.
Maksymalna wielkość datagramu zależy od wersji IP: 216−1 bajtów dla **IPv4** oraz 232−1
dla **IPv6**. Jeśli pakiet otrzymany z warstwy transportowej jest zbyt duży, zostanie podzielony
na kilka datagramów o odpowiedniej wielkości.
<br>
Zwykle dane dzielone są na mniejsze datagramy niż wynikałoby to z ograniczeń protokołu IP.
Jest to spowodowane ograniczonymi możliwościami fizycznymi sieci komputerowych. Na
przykład, maksymalna wielkość ethernetowych pakietów wynosi 1 500 bajtów, więc zwykle
datagramy tworzone w warstwie internetowej operującej na ethernecie będą nieco mniejsze
niż 1 500 bajtów (aby umożliwić niższym warstwom dodanie swoich nagłówków).
Maksymalna wielkość datagramu w sieci jest nazywana MTU (*Maximum Transfer Unit*).
IP umożliwia dzielenie datagramów na mniejsze datagramy, jeśli przechodzą one przez sieć z
mniejszą wartością MTU. Kiedy mniejsze datagramy docierają znowu do sieci o większej
wartości MTU, mogą zostać ponownie zebrane do większego pakietu. W nagłówku IP jest
specjalne pole pozwalające na przeprowadzanie takich operacji (nazywające się *Fragment Offset*).

### WARSTWA DOSTĘPU DO SIECI
Umożliwia przesłanie datagramów z warstwy internetowej, przez fizyczną sieć do drugiego
komputera, gdzie są one przesyłane przez odpowiadającą jej warstwę dostępu do sieci do
warstwy internetowej, a następnie poprzez pozostałe warstwy do docelowej aplikacji.
<br>Obecnie, większość komputerów jest podłączona do sieci ethernetowych, które mogą być
zarówno przewodowe jak i bezprzewodowe. Wobec tego protokoły TCP/IP wyższych warstw
najczęściej są używane razem z zestawem protokołów ethernetowych.


Istnieją **trzy** warstwy ethernetowe. Pierwsze dwie, **Logic Link Control (LLC)** i **Media Access Control (MAC)**, odpowiadają warstwie łącza danych w modelu OSI. Trzecia, najniższa warstwa
to warstwa fizyczna, podobnie jak w modelu OSI.

![alt text](resources/35-2.png)

### Warstwa LLC
Jej najważniejszym zadaniem jest przekazanie informacji do docelowej maszyny odnośnie
tego jaki protokół powinien być użyty w warstwie transportowej. Umożliwia to poprawne
odczytanie przychodzącej wiadomości przez odbiorcę. Warstwa LLC dopisuje informacje o
protokole użytym w warstwie internetowej i o protokole, który powinien otrzymać
wiadomość. Pozwala to warstwie LLC na docelowym komputerze poprawnie dostarczyć
otrzymane datagramy. Zdefiniowana przez standard IEEE 802.2.
### Warstwa MAC
jest odpowiedzialna za tworzenie końcowej wiadomości ethernetowej, która będzie wysłana
przez sieć komputerową. Podobnie jak inne warstwy, warstwa MAC tworzy swój własny
nagłówek i dodaje go do wiadomości. Nagłówek zawiera adresy MAC nadawcy i odbiorcy,
czyli fizyczne adresy dwóch komunikujących się maszyn. Jeśli docelowa maszyna znajduje się
za routerem, w innej sieci, to pole adresu odbiorcy będzie miało wartość adresu
### MAC
routera. Adres MAC odbiorcy będzie zmieniony na inny przez router, kiedy będzie on
przetwarzał wiadomość.
Warstwa MAC dodaje również 4 kontrolne bajty CRC, które mogą być wykorzystane do
naprawienia uszkodzonej wiadomości.
Warstwa MAC dla sieci przewodowych jest zdefiniowana przez standard IEEE 802.3. Sieci
bezprzewodowe są zdefiniowane przez IEEE 802.11.
Warstwa Fizyczna
Warstwa fizyczna jest odpowiedzialna za przekształcanie wiadomości w (zależności od typu
sieci) impulsy elektryczne lub fale elektromagnetyczne oraz za transmitowanie ich przez sieć
fizyczna pomiędzy komunikującymi się maszynami. Jest zdefiniowana przez te same
specyfikacje co warstwa MAC, IEEE 802.3 i IEEE 802.11.

## 37. Cykle życia oprogramowania.

### Podstawowe czynności związane z tworzeniem oprogramowania:

- Określanie wymagań i specyfikacji,
- Projektowanie,
- Implementacja,
- Testowanie - walidacja(atestowanie) i weryfikacja
- Konserwacja (pielęgnacja)

### Podstawowe modele cyklu życia oprogramowania:

1. Kaskadowy (*waterfall*)

![alt text](https://upload.wikimedia.org/wikipedia/commons/thumb/e/e9/POL_model_kaskadowy.svg/1200px-POL_model_kaskadowy.svg.png)

**Cechy:**
- Nie można przejśc do następnej fazy przed zakończneniem poprzedniej
- Błąd popełniony w początkowej fazie ma wpływ na całość
- model ten posiada bardzo nieelastaczny podział na kolejne fazy
- łatwy nadzór, dużo dokumentacji

2. Ewoulucyjny (np. Agile, Model Spiralny, Model Przyrostowy)

**Cechy:**
- adaptowanie systemu do zmian w wymaganiach i korygowanie popełnionych błędów
- turdne w nazdzorowaniu, wymaga dodatkowych strategii dla uporządkowania procesu wytwarzania oprogramowania

3. Model Komponentoway - Składanie systemu z gotowych komponentów.
4. Model Spiralny

![alt text](https://upload.wikimedia.org/wikipedia/commons/thumb/5/5b/ModelSpiralny.svg/1200px-ModelSpiralny.svg.png)

**Cechy:**
- Można wykorzystac gotowe komponenty
- Faza oceny w każdym cyklu pozwala uniknąć błędów lub wczesniej je wykryć
- Cały czas istnieje możliwość rozwijania projektu

**Cykl życia oprogramowania** - Okres czasu rozpoczynający się kiedy pojawił się pomysł na oprogramowanie  


## 38. Proces testowania i jego rola w tworzeniu oprogramowania.

**Testowanie Oprogramowania** - Jest to proces związany z wytwarzaniem oprogramowania. Jest on jednym z procesów kontroli jakości oprogramowania.

### Cele testowania:
- Weryfikacja oprogramowania - testowanie zgodności systemu z wymaganiami.
- Walidacja (atestowanie) oprogramowania - ocena systemu lub komponentu podczas lub na końcu procesu jego rozwoju na zgodności z wyspecyfikowanymi wymaganiami.
- Testowanie umożliwia wykrycie błędów we wczesnych stadiach rozwoju oprogramowania co pozwala zmniejszyć koszty usuwania tego błędu.	

Podstawowym standardem dla testowania oprogramowania jest IEEE 829-1998 (829 Standard for Software Test Documentation).

Rodzaje testów:
- Testy funkcjonalne. Polegają one na tym, że wcielamy się w rolę użytkowaika, traktując oprogramowanie jak, czarną skrzynkę", która wykonuje określone zadania. Nie wnikamy w ogóle w techniczne szczegóły działania programu. Testy te często są nazywane **testami czarnej skrzynki**.
- Testy strukturalne. Tym razem tester ma dostęp do kodu źródłowego oprogramowania, może obserwować jak zachowują się różne częsci aplikacji, jakie moduły i biblioteki sa wykorzystywane w trakcje testu. Te testy czasami sa nzywane **testami białej skrzynki**
<br>

**Testy Manualne**
Testy wykonywane ręcznie przez testera, który przechodzi przez interfejs użytkownika zgodnie z określoną sekwencją kroków:
- testy integracyjne,
- testy systemowe dotyczą działania aplikacji jako całość

**Testy dopasowane do aktualnego zapotrzebowania/przeznaczenia**
- testy funkcjonalne - znane również jako testy czarnej skrzynki,
- testy regresyjne - sprawdzają wpływ nowych funkcjonalności na działanie systemu,
- testy akceptacyjne z udziałem klienta,
- testy dokumentacji, których celem jest wykrycie niespójności i niezgodności z dokumentacją,
- testy użyteczności, których celem jest weryfikacja interfejsu użytkownika

**Testy automatyczne**
Testy automatyczne skutecznie przyspieszają proces tworzenia testów systemowych, ich wykonywanie oraz analize, a tym samym pozwalają na wcześniejsze wykrycie i weliminowanie błędów w aplikacjach.

### Co podlega testowaniu?
- wydajności systemu,
- interfejsy,
- właśności operacyjne systemu,
- testy zużycia zasobów,
- zabezpieczenie systemu,
- przenaszalność oprogramowania,
- niezawodność oprogramowania,
- odtwarzalność oprogramowania,
- bezpieczeństwo oprogramowania,
- kompletność i jakość złożonych funkcji systemu

## 39. UML, jego struktura i przeznaczenie.

### Czym jest **UML**
**UML** - Unified Modeling Language jest to język modelowy używany między innymi w inżynierii
oprogramowania jako standardowy sposób wizualizacji projektu systemu.

### Historia
Do kreacji **UML** przyczyniła się potrzeba standaryzacji różnych systemów wizualizacji systemów
rozwiazywania problemów. Został zaproponowany przez Rational software w połowie lat 90-
tych.
<br>
W 1997 **UML** został zaimplementowany przez Object Management Group jako główny system
organizacji, co było punktem przełomowym w popularyzacji języka.
<br>
W 2005 **UML** zostało zaadoptowane do standardu ISO (International Operation of
Standardization) i od tamtego czasu przechodzi okresowe rewizje, w 2020 roku wprowadzono
specyfikacje wersji 2.5.1


### JAK TO DZIAŁA
**UML** to sposób wizualizacji architektury systemów za pomocą diagramu.
UML składa się ze standardowych elementów, które mają na celu przyspieszenie pracy.
Diagram posiada sposoby wizualizacji miedzy innymi:
- Wszelkich prac
- Indywidualnych komponentów i jak one wzajemnie na siebie działają
- Jak użytkownik może komunikować się z systemem
  
**UML** nie narzuca żadnego systemu pracy, ani żadnego systemu projektowania
oprogramowania. Jest jednak narzędziem, która wspomaga projektowanie tych systemów.<br>
W programowaniu, bardzo dobrze sprawdza się jako sposób wizualizacji jak ma działać
program opierający się na obiektach.


### STRUKTURA DIAGRAMU
Są różne systemy i **UML** stara się zaproponować wizualizacje każdego z nich za pomocą
różnych elementów, wyspecjalizowanych lub nie. Idea natomiast jest taka sama.<br>
Diagram składa się z zawsze z wizualizacji danego obiektu, oraz interakcji między nimi.
Z takich standardowych przykładów używania UML możemy wymienić reprezentację systemu
za pomocą bramek logicznych.
### KATEGORIE
**UML** 2 posiada wiele typów diagramów, które można podzielić na 2 typy :
1. **Strukturalne** pokazują układ obiektów, lub całych systemów i interakcje między innymi.
![alt text](https://d2slcw3kip6qmk.cloudfront.net/marketing/blog/2019Q2/uml-diagrams/uml-composite-structure-diagram.png)

<br><br>

2. **Behawioralne** pokazują dynamiczne systemy, takie jak np algorytmy.
![alt text](https://p7x7q5i4.rocketcdn.me/en/wp-content/uploads/sites/2/2019/06/state-machine-diagram.jpg)
## 40. Podstawowe funkcje w zespole projektowym i ich role.

### Czym jest zespół projektowy?
Zespół projektowy jest to jednostka organizacyjna,
powołana na zasadzie specjalizacji przedmiotowej, realizująca projekt pod bezpośrednim nadzorem kierownika projektu.

### Czym jest Agile?
Grupa metod wytwarzania oprogramowania opartego na programowaniu iteracyjno-przyrostowym.
Najważniejszym założeniem metodyk zwinnych jest obserwacja, że wymagania odbiorcy
(klienta) często ewoluują
podczas trwania projektu. Pojęcie zwinnego programowania zostało zaproponowane w 2001 w
Manifeście Programowania Zwinnego.
### Manifest zwinnego programowania
„(...) Bardziej cenimy:<br>
**Ludzi** i **interakcje** od **procesów** i **narzędzi** **Działające**<br>
**oprogramowanie** od **szczegółowej**
**dokumentacji**<br>
**Współpracę z klientem** od **negocjacji** **umów** <br>
**Reagowanie na zmiany** od **realizacji założonego planu**.

Oznacza to, że elementy wypisane po prawej są wartościowe, ale większą wartość mają dla nas te, które wypisano po lewej.”

### SCRUM
Są to iteracyjne i przyrostowe ramy postępowania zgodne ze Scrum Guide.
Zgodnie z definicją ze Scrum Guide’a w obręb Scruma wchodzą: Zespoły Scrumowe oraz związane z nimi role,
wydarzenia, artefakty i reguły.
- ROLE: DEWELOPERZY + PRODUCT OWNER = ZESPÓŁ SCRUMOWY + SCRUM MASTER
- WYDARZENIA: PLANOWANIE SPRINTU + CODZIENNY SCRUM + PRZEGLĄD SPRINTU + RETROSPEKTYWA = SPRINT
- ARTEFAKTY: BACKLOG PRODUKTU + BACKLOG SPRINTU + PRZYROST
- REGUŁY: PRZEJRZYSTOŚĆ + INSPEKCJA + ADAPTACJA

### SCRUM - ROLE
ROLE: DEWELOPERZY + PRODUCT OWNER + SCRUM
MASTER = ZESPÓŁ SCRUMOWY
Deweloperzy, czyli zespół składający się z 3 9 osób z np.testera, analityka, webdewelopera, programisty
dowolnego języka. Odpowiadają za sposób wykonania zadań. W zespole wszyscy powinni być równi.
Product Owner odpowiada za wybór zadań do wykonania. Product Owner to osoba reprezentująca klienta ,
ciało jednoosobowe, jedyne, które może zlecać zadania zespołowi, dlatego bardzo ważne jest wsparcie jego roli
w organizacji.
Scrum Master czuwa nad tym, aby przebieg prac był zgodny z zasadami Scruma i ustalonymi przez zespół.
Osoba ta odpowiedzialna jest za usuwanie wszelkich przeszkód uniemożliwiających zespołowi wykonanie
zadania.

### SCRUM - WYDARZENIA
WYDARZENIA:
<br> PLANOWANIE SPRINTU
<br> CODZIENNY SCRUM + 
<br>PRZEGLĄD SPRINTU +
<br> RETROSPEKTYWA =
<br> SPRINT
<br>
- **Planowanie Sprintu** , służy ustaleniu na samym początku Sprintu, nad czym Zespół będzie pracował, w jaki sposób i dla
jakiego celu. Pieczę nad postępem pracy Zespół zapewnia sobie, organizując 
- **Codzienny Scrum** , czyli miniplanowania, które
służą codziennej weryfikacji stanu prac i ewentualnym korektom zaplanowanych zadań. 
- Na koniec Sprintu Zespół przedstawia
swoje dokonania Product Ownerowi i interesariuszom w czasie **Przeglądu Sprintu**
- Zaraz po tym weryfikuje swój sposób
pracy i wprowadza ulepszenia w czasie **Retrospektywy** .

### SCRUM - ARTEFAKTY
ARTEFAKTY: BACKLOG PRODUKTU + BACKLOG SPRINTU + PRZYROST
<br>Backlog Produktu to uporządkowana lista wszystkich rodzajów zadań potrzebnych do rozwoju, utrzymania i naprawy produktu.
Lista ta jest otwarta dla wszystkich w organizacji, natomiast Product Owner ma ostateczne słowo co do treści, wyglądu i
zawartości Backlogu. To jest jego narzędzie pracy nad produktem.
Backlog Sprintu to analogiczne narzędzie, ale dla Zespołu Deweloperskiego, który dzięki temu artefaktowi w pełni panuje nad
pracami zaplanowanymi na Sprint.
Przyrost to ukończona przez Zespół zgodnie z Definicją Ukończenia praca na koniec każdego i wszystkich razem Sprintów.

### SCRUM - REGUŁY
REGUŁY: PRZEJRZYSTOŚĆ + INSPEKCJA + ADAPTACJA
<br> Przejrzystość zapewnia Zespowi Scrumowemu i wszystkim w organizacji dostęp do całości prac i takie samo rozumienie
każdego elementu Scruma. Dzięki temu nie ma niejasności i nieporozumień.
Inspekcja pozwala na bieżące monitorowanie i weryfikowanie przedmiotu pracy i sposobu pracy Zespołu.
Adaptacja powinna być wynikiem Inspekcji i prowadzić do niezbędnych zmian naprowadzających Zespół na właściwy tor
pracy.
