### 11. System operacyjny. Postrzeganie systemu operacyjnego przez warstwę oprogramowania użytkowego.

<a href="https://wazniak.mimuw.edu.pl/images/5/57/Sop_01_wyk_bw_1.1.pdf"> Źródło: wykład "Wprowadzenie do systemów operacyjnych"</a>

<h4>Definicja</h4>

**System operacyjny** jest warstwą oprogramowania operującą bezpośrednio na sprzęcie, której celem jest zarządzanie zasobami systemu komputerowego i
stworzenie użytkownikowi środowiska łatwiejszego do zrozumienia i wykorzystania.

<center>

![System operacyjny w architekturze komputera](./resources/11-1.png)

</center>

System operacyjny *pośredniczy* pomiędzy użytkownikiem a sprzętem,
dostarczając wygodnego środowiska do wykonywania programów. Użytkownik
końcowy korzysta z programów (aplikacji), na potrzeby których przydzielane są
zasoby systemu komputerowego. Przydziałem tym zarządza system operacyjny,
dzięki czemu można uzyskać stosunkowo duży stopień niezależności programów
od konkretnego sprzętu oraz odpowiedni poziom bezpieczeństwa i sprawności
działania.

<h4> Ogólna struktura systemu operacyjnego </h4>

Nie ma precyzyjnego określenia, które składniki wchodzą w skład systemu
operacyjnego jako jego części.
<center>

![System operacyjny w architekturze komputera](./resources/11-2.png)

</center>

W ogólnym przypadku w strukturze systemu operacyjnego wyróżnia się jądro
oraz programy systemowe, które dostarczane są razem z systemem operacyjnym,
ale nie stanowią integralnej części jądra. **Jądro** jest zbiorem modułów, które
ukrywają szczegóły sprzętowej realizacji systemu komputerowego, udostępniając
pewien zestaw usług, wykorzystywanych między innymi do implementacji
programów systemowych.

Z punktu widzenia kontaktu z użytkownikiem istotny jest **interpreter poleceń**,
który może być częścią jądra lub programem systemowym (np. w systemie
UNIX). Interpreter wykonuje pewne polecenia wewnętrznie, tzn. moduł lub
program interpretera dostarcza implementacji tych poleceń. Jeśli interpreter nie
może wykonać wewnętrznie jakiegoś polecenia, uruchamia odpowiedni program
(tzw. polecenie zewnętrzne), jako odrębny proces.

**Programy systemowe (programy użytkowe systemu)**:
<ul>
<li>programy do obsługi plików, w tym pakujące i archiwizujące</li>
<li>programy do komunikacji w sieci</li>
<li>proste edytory tekstów i grafiki</li>
<li>programy diagnozujące pracę procesora, pamięci, sieci, dysków twardych itp</li>
<li> kompilatory </li>
</ul>

**Zadania systemu operacyjnego:**
<ul>
<li> Definicja interfejsu użytkownika </li>
<li> Udostępnianie systemu plików </li>
<li> Udostępnianie środowiska do wykonywania
programów użytkownika </li>
  <ul>
    <li> mechanizm ładowania i uruchamiania programów</li>
    <li> mechanizmy synchronizacji i komunikacji procesów </li>
  </ul>
<li>Sterowanie urządzeniami wejścia-wyjścia</li>
<li>Obsługa podstawowej klasy błędów</li>
</ul>

<h4>Podział systemów operacyjnych</h4>
<ul>
<li> Ze względu na sposób przetwarzania </li>
<ul>
<li>systemy przetwarzania bezpośredniego (online processing systems) - bezpośrednia interakcja użytkownik<->system</li>
<li>systemy przetwarzania pośredniego (offline processing systems) - zwłoka czasowa; brak możliwości ingerencji w wykonywanie zadania</li>
</ul>

<li> Ze względu na liczbę wykonywanych programów </li>
<ul>
<li>jednozadaniowe - tylko jedno zadanie na raz</li>
<li>wielozadaniowe - wiele zadań jednocześnie</li>
</ul>

<li> Ze względu na liczbę użytkowników </li>
<ul>
<li>dla 1 użytkownika - tylko jedno zadanie na raz</li>
<li>wielozadaniowe - wielu użytkowników może
korzystać ze zasobów systemu komputerowego, a
system operacyjny gwarantuje ich ochronę przed
nieupoważnioną ingerencją</li>
</ul>
</ul>

#### **Procesy**

**Proces** - uruchomiony program. Jeden program to może być wiele procesów, bo np. uruchomimy wiele razy ten jeden program. Każdy proces jest identyfikowany przez numer PID.

W systemie operacyjnym każdy proces posiada proces nadrzędny (rodzica), z kolei każdy proces może, poprzez wywołanie funkcji systemu operacyjnego, utworzyć swoje procesy potomne. W ten sposób tworzy się swego rodzaju drzewo procesów.

W *skład procesu* wchodzi:
<ul>
<li>kod programu</li>
<li>licznik rozkazów</li>
<li>stos</li>
<li>sekcja danych</li>
</ul>

W trakcie ładowania procesu do pamięci system operacyjny tworzy *stos* (stack) i *stertę* (heap). 

**Stos** – do przechowywania zmiennych, parametrów funkcji, adresów powrotu.
**Sterta** – do przechowywania dynamicznie alokowanych danych, np. listy

**Stany procesu**:
<ul>
<li><b>Początkowy</b> (initial) – w trakcie uruchamiania</li>
<li><b>Aktywny</b> (running, executing)– proces działa na procesorze</li>
<li><b>Gotowy</b> (ready) – proces jest gotowy do uruchomienia, ale w tej chwili jest wstrzymany</li>
<li><b>Oczekujący</b> (blocked) ; proces wykonał operację w wyniku której nie może zostać ponownie uruchomiony dopóki nie nastąpi jakieś zdarzenie (np. operacja we/wy).</li>
<li><b>Końcowy</b> (final) – podczas zamykania</li>
<li><b>Zombie</b> – ukończony proces, który czeka na jakąś akcję, np. odczytanie kodu wyjścia przez proces rodzica</li>
<li><b>Demon</b> (ang. daemon czyli duszek) - nazywamy proces działający w tle, nie podlegający sterowaniu z żadnego terminala, uruchamiany zwykle podczas startu systemu i działający do jego zamknięcia.</li>
</ul>

#### **Wątek**
Czasami może być konieczne współbieżne wykonywanie pewnych fragmentów programu. Aby to zrealizować, program może zażądać utworzenia określonej liczby wątków, wykonujących wskazane części programu. Ta cecha systemu operacyjnego to wielowątkowość. W jednym procesie może być kilka wątków. Każdy wątek ma swój własny stos (posiada swoje zmienne lokalne)

#### **Wielozadaniowość**
Cecha systemu operacyjnego umożliwiająca równoczesne wykonywanie więcej niż jednego procesu (programu).

#### **Planista (dyspozytor)**
Jest jak policjant na skrzyżowaniu, który wskazuje, które auta mogą teraz przejechać przez skrzyżowanie. Jest to część systemu operacyjnego przełączająca procesy według polityki szeregowania zadań. Do jego zadań należy m.in. przełączanie kontekstu.

**Planista krótkoterminowy** ustala wartość priorytetu. Wybiera proces o najwyższym priorytecie do wykonania.

#### **Algorytmy szeregowania**
<ul>
<li><b>FIFO</b> – (FCFS) - najprostszy, niewywłaszczający, implementowany za pomocą kolejki FIFO;</li>
<li><b>SJF</b> (Shortest-Job-First) - wiąże z każdym procesem długość jego najbliższej z faz procesora, zapewnia minimalny średni czas oczekiwania; może być wywłaszczający lub nie;</li>
<li>algorytm <b>Round-Robin</b> - czas procesora podzielony na kwanty, kolejka procesów gotowych traktowana jako kolejka cykliczna, algorytm z wywłaszczeniem;</li>
</ul>

<center>

![Algorytmy szeregowania-przykład](./resources/11-3.png)

</center>

 Możliwe jest **zagłodzenie** procesu, gdy dany proces nie jest w stanie zakończyć działania,
  ponieważ nie ma dostępu do procesora lub innego współdzielonego zasobu.
Występuje
 najczęściej na skutek niewłaściwej pracy algorytmu szeregowania lub nadmiernego obciążenia
 systemu.

 Zdarza się również tzw. **zakleszczenie**, czyli blokada wzajemna. Powstaje wtedy, gdy wiele
 zadań w tym samym czasie konkuruje o wyłączny dostęp do zasobów. Zakleszczenie:

 <center>

![Zakleszczenie-przykład](./resources/11-4.png)

</center>
 
### 12. Cechy tradycyjnego systemu :sparkling_heart: Unixowego :sparkling_heart:.

<a href="https://ai.ia.agh.edu.pl/_media/pl:dydaktyka:unix:gjn-unix-2015wiosna-lec1_4.pdf"> Polecanko - slajd 46+</a>
<h4>TL;DR: Unix to system </h4>
<ul>
<li><b>wielozadaniowy</b> - jest to cecha systemu operacyjnego, mówiąca, czy może on wykonywać jednocześnie kilka procesów. Wielozadaniowość otrzymuje się poprzez tzw. scheduler, czyli algorytm kolejkujący i porządkujący procesy, które mają być wykonane. W tym systemie każdy proces jest wykonywany jakiś kwant czasu, a później czeka "w uśpieniu" (oczywiście z uwzględnieniem różnych priorytetów).</li><br>

<li><b>wielodostępowy</b> (o ile jego administrator nie zażyczy sobie inaczej) - oznacza możliwość jednoczesnej pracy wielu użytkowników (np. możliwość czytania tego samego pliku przez kilku użytkowników)</li><br>

<li><b>wielowątkowy</b> – jest to cecha systemu operacyjnego, dzięki której w ramach jednego procesu można wykonywać kilka wątków lub jednostek wykonawczych. Nowe wątki to kolejne ciągi instrukcji wykonywane oddzielnie. Wszystkie wątki współdzielą między sobą ten sam obszar pamięci. W momencie, gdy system nie wspiera wielowątkowości, pojęcie procesu i wątku utożsamiają się.</li>
</ul>

<h4>Cechy</h4>

<ol>

<li> <b>Jądro</b> systemu jest, oprócz pewnej części ściśle związanej z obsługiwanym sprzętem,
<b>napisane w języku wysokiego poziomu (C)</b>.</li>
<br>
<li>W Unixie obowiązuje model administracyjny, bazujący na <b>ograniczonym zaufaniu do użytkowników</b>. Ujawnia się on między innymi tym, że zwykle użytkownik lokalny ma
prawo zapisu jedynie w swoim katalogu domowym, katalogu na pliki tymczasowe oraz w kilku innych, dobrze znanych miejscach. Jednocześnie administratora systemu
(użytkownika o numerze identyfikacyjnym 0) nie dotyczą jakiekolwiek ograniczenia.</li><br>
<li><b>System praw dostępu do plików</b> (czyli również do urządzeń czy kanałów komunikacyjnych) jest zbudowany w oparciu o tablicę bitową stałej długości, zapisaną w i-węźle. Zawiera ona zezwolenia na trzy podstawowe operacje – czytanie, zapis i wykonanie dla trzech rozłącznych klas użytkowników: właściciela pliku, członków tzw. grupy pliku oraz innych. Unixowy system praw dostępu jest bardzo efektywny w działaniu, brak dynamicznych list dostępu jest jednakże dość uciążliwy.</li><br>
<li>Unix bezpośrednio po starcie widzi tylko jedno urządzenie pamięci masowej, zawierające tzw. korzeń systemu plików (oznaczany znakiem /). Inne urządzenia są przyłączane do głównego drzewa w procesie tzw. montowania i są widoczne jako fragmenty drzewa plikowego od pewnego katalogu określanego jako punkt montowania.</li><br>
<li>Naturalnym sposobem <b>organizacji pamięci masowej</b> jest model indeksowy oparty na tzw. i-węzłach (ang. i-nodes). i-węzeł zawiera w postaci tablicy o stałym rozmiarze wszystkie informacje o pliku poza jego nazwą. Odwzorowaniem i-węzłów na nazwy plików zajmują się pliki specjalne – katalogi.</li><br>
<li>Budowie interfejsu programisty systemu (API) prześwięca minimalizm, ujawniający się choćby tym, że odczyt i zapis informacji w rozmaitych urządzeniach obsługiwanych przez system odbywa się za pomocą tego samego interfejsu jak odczyt i zapis informacji do plików „zwykłych”. Zasadę tę często definiuje się jako: „Dla Unixa wszystko jest plikiem”. </li><br>
<li>Jednostką aktywną w systemie jest <b>proces</b>, pracujący w trybie nieuprzywilejowanym procesora, we własnej chronionej przestrzeni adresowej; jedynym elementem aktywnym w trybie uprzywilejowanym jest jądro systemu. </li><br>
<li>Unix wykorzystuje do pracy w środowisku rozproszonym rodzinę protokołów TCP/IP. </li><br>
<li>Plik danych jest ciągiem bajtów. </li><br>
<li>Unix używa pamięci wirtualnej, rozszerzając pamięć operacyjną o tzw. obszary wymiany w pamięci masowej. Niewykorzystaną pamięć operacyjną wypełniają bufory używanych plików.</li><br>
<li>Podstawową metodą tworzenia nowych procesów jest rozwidlanie procesu aktywnego funkcją systemową fork. Po jej wywołaniu system tworzy nowy proces, którego przestrzeń adresowa jest kopią przestrzeni procesu macierzystego. Oba procesy rozpoczynają współbieżną pracę od następnej instrukcji za wywołaniem fork. Często proces potomny wykonuje niedługo po utworzeniu funkcję systemową execve, która zastępuje kod aktywnego procesu kodem z pliku wykonywalnego. </li><br>
<li>Otwarty plik jest dostępny w procesie poprzez liczbę całkowitą zwaną <b>deskryptorem pliku</b>. Predefiniowanymi deskryptorami są tu wartości 0 (standardowe wejście, zwykle związane z klawiaturą terminala), 1 (standardowe wyjście, zwykle z związane z wyjściem terminala) oraz 2 (standardowe wyjście dla błędów). </li><br>
<li>W środowisku tekstowym naturalnym środowiskiem pracy jest tzw. Interpreter poleceń czyli powłoka (ang. shell).</li><br>
<li>Unixowy system plików jest widoczny jako wielopoziomowe drzewo.</li><br>
<li>Procesy korzystają podczas pracy z mechanizmów łączenia dynamicznego, ładując kod wspólnych bibliotek w miarę potrzeb. Podstawową biblioteką uwspólnioną jest standardowa biblioteka języka C (tzw. libc).</li><br>
<li>Komunikacja międzyprocesowa odbywa się przez jądro systemu.</li><br>
</ol>

<h4>Typy plików Unixowych</h4>
<ul>
<li><b>pliki zwykłe</b> – (symbol: -) ciągi bajtów, może istnieć w kilku miejscach w systemie plików jednocześnie.</li><br>

<li><b>katalogi</b> – (symbol: d) plik binarny zawierający listę plików oraz katalogów, które się w nim znajdują. Typowe operacje dostępu do pliku, np. otwarcie, nie działają dla katalogu. Dowiązania sztywne do katalogu są tworzone jedynie pośrednio przez system. Każdy katalog zawiera dwie specjalne pozycje:
<ul>
<li>. – wskazującą na ten katalog
<li>.. – wskazującą na katalog zawierający.
</ul>
<br>

<li><b>dowiązanie symboliczne</b>, (ang. symbolic link, często skracane jako symlink) wskazuje, odwołując się za pomocą nazwy, na dowolny inny plik lub katalog (który może nawet w danej chwili nie istnieć). Odwołanie jest niewidoczne na poziomie aplikacji tzn. jest traktowane jak zwykły plik lub katalog.</li><br>

</ul>


### 13. Iteracja, rekurencja i ich realizacja.
<a href="https://fulmanski.pl/zajecia/wdi/zajecia_20212022/wyklad_pres/pres_pl_algorithm.pdf"> Źródło :duck: :fire:</a>


**Iteracja** - czynność powtarzania (najczęściej wielokrotnego) tej samej instrukcji (albo wielu instrukcji) w pętli.

**Rekurencja** to w logice, programowaniu i w matematyce odwoływanie się np. funkcji lub definicji do samej siebie.

Najwięcej problemów związanych z rekurencją wiąże się z ograniczeniami
stosu wywołań, a właściwie jego pojemności. Na stosie są odkładane kolejne wywołania danej metody i dopiero gdy dojdziemy do ostatniego elementu dane te są zbierane – bardzo łatwo więc o sytuację, gdy po prostu stos przepełnimy.

<h4>Klasyczne przykłady</h4>

**Silnia iteracyjnie:** n! = 1 \* 2 \* 3...* n <br>
**Silnia rekurencyjnie:** n! = n \* (n-1)!


**Ciąg Fibonacciego**

*Definicja*: dla $n>1$ mamy
$$fib_n = fib_{n-1} + fib_{n-2}, $$
natomiast wyrazy 1 i 0 przyjmują wartość 1.

**Fibonacci rekurencyjnie:**
```
function FibR(n)
begin
      if ( n=0 or n=1) then {
          return 1
      }  
      return FibR(n-1) + FibR(n-2)
end
```
**Fibonacci iteracyjnie:**
```
function FibI(n)
begin
    tmp :=0 // zmienna tymczasowa (pomocnicza)
    x := 1 // wyraz n-1
    y := 1 // wyraz n-2

    for i:=1 to n-1 step 1 {
      tmp := y   // zapamiętaj wyraz n-2
      y := y+x   // przesuń wyraz n-2 na kolejną wartość ci¡gu
      x := tmp   // przesuń wyraz n-1 na kolejną wartość ci¡gu
                 // czyli na warto±¢ wyrazu n-1 przed jego
                 // przesunięciem
    }
    return x
end
```

### 14. Mechanizmy strukturalizacji programów - instrukcje warunkowe i pętle.

I mean..come on ;-;

<a href="https://home.agh.edu.pl/~pkleczek/dokuwiki/doku.php?id=dydaktyka:cprog:2015:conditionals"> For disabled folks</a>

**Switch syntax**
```
switch(expression) {
  case x:
    // code block
    break;
  case y:
    // code block
    break;
  default:
    // code block
}
```

>Note: The default keyword must be used as the **last statement** in the switch, and it **does not need a break**. *default* can be the first statement on the list, but it makes no sense since only this statement will be executed. 

> **break** and **default** keywords are *optional*.

>Without a break statement, **every statement** from the matched case label to the end of the switch, including the default, is executed.

</br>

#### **switch statement behavior**

<table align="center" >
    <thead>
        <tr>
            <th>Condition</th>
            <th>Action</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>Converted value matches that of the promoted controlling expression.</td>
            <td>Control is transferred to the statement following that label.</td>
        </tr>
        <tr>
            <td>None of the constants match the constants in the case labels; a default label is present.</td>
            <td>Control is transferred to the default label.</td>
        </tr>
        <tr>
            <td>None of the constants match the constants in the case labels; no default label is present.</td>
            <td>Control is transferred to the statement after the switch statement.</td>
        </tr>
    </tbody>
</table>

<a href="https://docs.microsoft.com/en-us/cpp/cpp/switch-statement-cpp?view=msvc-170">Switch documentation</a>


## 15. Podprogramy. Przekazywanie parametrów podprogramu.

**Podprogramy** – wydzielona część programu wykonująca określony zbiór instrukcji, posiadająca swoją nazwę i stanowiąca pewną odrębną całość. Ich nazwy powinny informować o ich wyniku działania.

Ogólnie przyjęta konwencja (w przypadku C++) typ_rezultatu nazwa_funkcji( lista parametrów formalnych); na przykład:
```
bool isPrime(int);
```

**Podprogramy dzielą się na dwa rodzaje:**
<ul>
<li>funkcje, które operują na otrzymanych w parametrach danych, zwracają pewną obliczoną wartość, ale nie ingerują w działanie programu.</li>
<li>procedury mogą przyjmować parametry, a w wyniku ich działania następują zmiany globalne w programie bądź w otrzymanych parametrach; po swoim działaniu nie zwraca niczego.</li>
</ul>

Innym szczególnym przypadkiem są *metody* – funkcje, które są własnością klasy lub obiektu. Bez ich istnienia nie można się do nich odwołać.

>W niektórych językach programowania nie istnieje powyższy podział.

Jeżeli chodzi o C++, formalnie procedury nie istnieją, jednak łatwo się domyślić, że ustawiając jako typ rezultatu void możemy utworzyć coś na jej wzór.

**Przekazywanie parametrów do podprogramów odbywa się głównie na dwa sposoby:**
<ul>
<li><b>przez wartość</b> – wewnątrz bloku podprogramu tworzona jest zmienna lokalna, do której kopiowana jest wartość przekazanego parametru, a następnie wszystkie operacje wykonywane są na kopii. Po zakończeniu działania podprogramu wszystkie kopie przestają istnieć, zaś oryginalna zmienna pozostaje niezmieniona</li>

<li><b>przez referencję</b> – do podprogramu przekazywany jest bezpośredni dostęp do zmiennej, a nie jedynie jej wartość, co zmniejsza zużycie pamięci oraz umożliwia modyfikację zmiennej, której efekty pozostaną także po zakończeniu działania podprogramu.</li>
</ul>

```
int addOne(int number) {
    return number++; //przez wartość
}

int addOne(int &number) {
    return number++; //przez referencję
}
```
## 16. Porównanie programowania obiektowego i strukturalnego.

**Programowanie strukturalne** – paradygmat programowania opierający się na podziale kodu źródłowego programu na procedury i hierarchicznie ułożone bloki z wykorzystaniem *struktur kontrolnych* w postaci instrukcji wyboru i pętli. Język programowania zgodny z paradygmatem programowania strukturalnego nazywa się językiem strukturalnym.

**Struktury kontrolne:**
<ul>
<li><b>Sekwencja</b> – wykonanie ciągu kolejnych instrukcji.</li>
<li><b>Wybór</b> – w zależności od wartości wykonywana jest odpowiednia instrukcja. W większości języków programowania są to instrukcje takie jak: if, else, switch, case.</li>
<li><b>Iteracja</b> – wykonywanie instrukcji póki spełniony jest jakiś warunek. Repreezntowana w różnych wariantach jako pętle oznaczane między innymi przez: while, for, do (...) while.</li>
<li><b>Podprogramy</b> - pozwalają na wydzielenie pewnej grupy instrukcji i traktowania ich jako pojedynczej operacji, są dodatkowo mechanizmem abstrakcji.</li>
<li><b>Bloki</b> - w językach programowania bloki odpowiadają sekwencjom instrukcji, umożliwiając budowanie programu przez komponowanie struktur kontrolnych – w miejscu, w którym umieścimy blok z instrukcjami jest on traktowany jak pojedyncza instrukcja.</li>
</ul>

**Programowanie obiektowe** – paradygmat programowania, w którym programy definiuje się za pomocą obiektów – elementów łączących stan i zachowanie. Obiektowy program komputerowy wyrażony jest jako zbiór takich obiektów, komunikujących się pomiędzy sobą w celu wykonywania zadań.

<table align="center">
    <thead>
        <tr>
            <th></th>
            <th><center>Zalety</center></th>
            <th><center>Wady</center></th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>Programowanie strukturalne</td>
            <td>
                <ul>
                    <li>szybkie wykonywanie skryptów</li>
                    <li>mała liczba zmiennych (oszczędność pamięci)</li>
                    <li>prostota formy kodu</li>
                </ul>
            </td>
            <td>
                <ul>
                    <li>trudna modyfikacja kodu</li>
                    <li>rozdzielenie danych i operacji na nich wykonywanych</li>
                    <li>częsty nieporządek w kodzie, utrudniający jego czytanie</li>
                </ul>
            </td>
        </tr>
        <tr>
            <td>Programowanie obiektowe</td>
            <td>
                <ul>
                    <li>wysoka przejrzystość kodu</li>
                    <li>łatwość modyfikacji, rozbudowy oraz konserwacji kodu</li>
                    <li>małe ryzyko błędów przy zmianach</li>
                    <li>ułatwia współpracę wielu programistów</li>
                </ul>
            </td>
            <td>
                <ul>
                    <li>wolniejszy czas wykonywania</li>
                    <li>częsta potrzeba wykorzystania nadmiaru kodu do zdefiniowania klas</li>
                </ul>
            </td>
        </tr>
    </tbody>
</table>


## 17. Hermetyzacja danych - cechy klas obiektowych (pola, metody, poziomy prywatności danych).

>aka enkapsulacja

Polega na **ukrywaniu informacji** - ukrywanie pewnych danych składowych lub metod w obiektach danej klasy tak, aby były one dostępne tylko dla metod wewnętrznych danej klasy lub dla metod z klas z nią zaprzyjaźnionych.

Z *pełną enkapsulacją* mamy do czynienia wtedy gdy dostęp do wszystkich pól w klasie jest możliwy tylko i wyłącznie poprzez metody, lub inaczej: gdy wszystkie pola w klasie znajdują się w sekcji prywatnej (lub chronionej)

**Ukrywanie wewnętrznej struktury obiektu jest bardzo ważne z kilku powodów (Zalety):**
<ul>
<li>obiekt taki jest odizolowany, a więc nie jest narażony na celowe, bądź niezamierzone działanie ze strony użytkownika</li>
<li>obiekt ten jest chroniony od niepożądanych referencji ze strony innych obiektów.</li>
<li>dzięki ukryciu wewnętrznej struktury obiektu, można uzyskać jego przenośność. Innymi słowy, zastosować definiującą go klasę w innym fragmencie kodu, czy też programie.</li>
<li>Uodparnia tworzony model na błędy polegające na przykład na błędnym przypisywaniu wartości oraz umożliwia wykonanie czynności pomocniczych</li>
<li>Umożliwia rozbicie modelu na mniejsze elementy.</li>
</ul>

**Klasa** to definicja obiektu, zawierająca stan obiektu, określony wartościami pól, oraz możliwe zachowanie, określone dostępnymi metodami.

**Obiekt** to utworzony egzemplarz (instancja) określonej klasy, który posiada własny, indywidualny stan i zbiór zachowań.

**Metoda** to funkcja lub procedura, skojarzona z ogółem klasy lub poszczególnymi jej obiektami; określa możliwe zachowania

**Pole** (Właściwość) to zmienna dowolnego typu, skojarzona z ogółem klasy lub poszczególnymi jej obiektami; określa aktualny stan obiektu

**Dziedziczenie** to mechanizm definiowania nowej klasy na bazie już istniejącej, wzbogacając ją o nowe pola, metody lub zmieniając zakres ich widoczności.

**Zmienna składowa lub metoda może mieć trzy różne poziomy dostępności:**
<ul>
<li><b>public</b> - dostęp publiczny dla innych struktur/klas i funkcji</li>
<li><b>private</b> - dostęp prywatny, tylko dla metod struktury/klasy</li>
<li><b>protected</b> - dostęp chroniony, dla metod struktury/klasy i jej struktur/klas
pochodnych (dziedziczenie)</li>
<li><b>friend</b> - deklaracja przyjaźni, dostęp dla wyspecyfikowanych struktur/klas
lub funkcji</li>
</ul>

>Struct - wszystkie składowe (pola i metody) są domyślnie **publiczne**

>Class - wszystkie składowe (pola i metody) są domyślnie **prywatne**
## 18. Typy metod: konstruktory, destruktory, selektory, zapytania, iteratory.

Metoda
<ul>
<li>Funkcja składowa</li>
<li>Funkcja powiązana z klasą</li>
<li>Funkcja mająca dostęp do składowych klasy</li>
<li>Tworzy interfejs klasy</li>

```
class MyClass {
    void privateMethod(); //deklaracja w klasie

public:
    void publicMethod() { //definicja w klasie
        //donothing;
    }; 
}
```
</ul>

>Definicja klasy musi zawierać przynajmniej deklarację metody

>Definicja metody, często dla czytelności kodu, jest umieszczana
poza klasą

```
void MyClass::privateMethod() { //definicja poza klasą
    //this method is depressed
}
```

#### **Konstruktory**

<ul>
<li><b>Konstruktor</b> – specjalna metoda do inicjalizacji atrybutów obiektu</li>
<li>uruchamiany zawsze przy tworzeniu obiektu</li>
<li>nazwa metody taka jak nazwa klasy</li>
<li>możliwe wiele przeciążeń z różnymi parametrami, <b>brak typu wynikowego!</b></li>

```
struct Obj {
    int a, b;   //od C++11 możliwa inicjalizacja w klasie, np.
                //int a = 0;

    Obj(int _a = 0, int _b = 0){ //konstruktor
        a = _a;
        b = _b;
    }
};

{
    Obj x, y(1), z(1,2), v = 3, u = {3,4}; //wywołania konstruktora
    Obj t[5], *s = new Obj, *p = new Obj[3]; //wielokrotne
}
```
</ul>

**Konstruktor domyślny:**
<ul>
<li>bez parametrów (lub gdy wszystkie parametry mają wartości domyślne) </li>
<li>tworzony automatycznie przez kompilator (bez gwarancji inicjalizacji atrybutów
obiektu) tylko gdy nie zdefiniowano jawnie żadnego konstruktora</li>

```
struct Obj {
    int a, b;

    Obj(){ //konstruktor domyślny
        a = 0;
        b = 0;
    }
    
    Obj()=default;//konstruktor domyślny bez inicjalizacji(C++11)
};

{
    Obj x, t[5]; //wywołania konstruktora domyślnego
    Obj *s = new Obj, *p = new Obj[3]; //tu też
}
```
<li><b>(!!!) jeżeli jakikolwiek konstruktor został zdefiniowany, kompilator nie tworzy
domyślnego</b> </li>
<li>w celu ułatwienia wykorzystania klasy należy zawsze zdefiniować konstruktor
domyślny </li>

```
struct Obj {
    int a, b;
    
    Obj(int _a, int _b = 0){ //1- lub 2-parametrowy konstruktor
        a = _a;
        b = _b;
    }
};

{
    Obj y(1), z(1, 2); //wywołania konstruktora
    Obj x; //brak konstruktora domyślnego – błąd kompilacji!
}
```
</ul>

**Konstruktor kopiujący:**
<ul>
<li>przyjmuje jako jedyny parametr referencję do obiektu tej samej klasy </li>
<li>tworzony automatycznie przez kompilator gdy nie zdefiniowano jawnie takiego
konstruktora (kopia atrybutów obiektu)</li>
<li>wywoływany przy przekazywaniu i zwracaniu obiektów w funkcjach</li>

```
struct Obj {
    int a, b;
    ... //inne konstruktory łącznie z domyślnym

    Obj(const Obj &o){ //konstruktor kopiujący
        a = o.a;
        b = o.b;
    }
};

{
    Obj x;
    Obj y(x), z = x; //wywołania konstruktora kopiującego
}
```
</ul>

#### **Destruktory**
<ul>
<li><b>destruktor</b> – specjalna metoda do zwolnienia pamięci zajmowanej przez obiekt</li>
<li>wywoływany automatycznie gdy zmienna przestaje istnieć (na końcu bloku)</li>
<li>metoda o nazwie takiej jak nazwa klasy lecz z poprzedzającą tyldą (~)</li>
<li><b>możliwy tylko jeden destruktor, brak typu wynikowego!</b></li>

```
struct Obj {
    int a, b;
    ... //konstruktory łącznie z domyślnym
    
    ~Obj(){...} //destruktor
    ~Obj()=default; //destruktor domyślny (C++11)
};

{
    Obj x, *p = new Obj; //wywołania konstruktora
    delete p; //jawne wywołanie destruktora (obiekt *p)
} //niejawne wywołanie destruktora (obiekt x)
```
</ul>

**Destruktory obiektów:**
<ul>
<li>tworzone automatycznie przez kompilator gdy nie zostaną jawnie zdefiniowane
(destruktor domyślny nie zwalnia pamięci dla atrybutów klasy alokowanych
dynamicznie za pomocą operatora new)</li>
<li>uruchamiane w kolejności odwrotnej do kolejności tworzenia obiektów
(wywołań odpowiednich konstruktorów)</li>

```
{
    Obj x, *p = new Obj, z;

    { Obj y; } //destruktor dla obiektu y

    delete p; //destruktor dla obiektu *p
} //destruktor dla obiektu z i dalej dla x
```
</ul>

**Kiedy wywoływany jest destruktor?**
<ul>
<li>Decyzję o wywołaniu destruktora podejmuje kompilator. Kod nie powinien jawnie wywoływać destruktora.</li>
<li>Jeżeli obiekt tworzony jest w pamięci statycznej, wówczas jego destruktor wywoływany jest przed zakończeniem programu.</li>
<li>Jeżeli obiekt tworzony jest w sposób automatyczny wówczas destruktor jest wywoływany kiedy program opuszcza blok kodu w którym został zdefiniowany ten obiekt.</li>
<li>Jeżeli obiekt utworzono w sposób dynamiczny (tzn. za pomocą operatora new), wówczas destruktor tego obiektu jest wywoływany automatycznie, gdy użyjemy delete do zwolnienia pamięci.</li>
</ul>

#### **Metody domyślne**

Dla każdej klasy kompilator tworzy **automatycznie (o ile nie zdefiniowano ich
jawnie)** następujące metody:
<ul>
<li>konstruktor domyślny (bezparametrowy, brak incjalizacji)</li>
<li>konstruktor kopiujący (kopia atrybutów)</li>
<li>destruktor (brak zwolnienia dynamicznej pamięci)</li>
<li>operator przypisania (kopia atrybutów)</li>

```
struct Obj {
    int a, b;
};

{
    Obj x; //konstruktor domyślny, atrybuty są przypadkowe
    Obj y = x; //konstruktor kopiujący
    x = y; //operator przypisania
} //destruktor domyślny obiektów y i x
```
</ul>

<a href="http://math.uni.lodz.pl/~cybula/psd/lec1.pdf">^Źródło</a>

**Iteratory**

W programowaniu obiektowym jest to obiekt pozwalający na sekwencyjny dostęp do wszystkich elementów lub części zawartych w innym obiekcie, zwykle kontenerze 
lub liście.

Podstawowym celem iteratora jest pozwolić użytkownikowi przetworzyć każdy element w kolekcji bez konieczności zagłębiania się w jej wewnętrzną strukturę. 
Np.: przejść do kolejnego elementu, na koniec na początek. Użytkownik nie musi np. zajmować się tym, że odwoła się do nieistniejącego elementu.

W C++ iteratory są szeroko wykorzystywane w bibliotece STL. Iteratory stosuje się zwykle w parach, gdzie jeden jest używany do właściwej iteracji, zaś drugi oznacza koniec 
kolekcji. 

Iteratory tworzone są przez odpowiadający im kontener standardowymi metodami, takimi jak **begin()** i **end()**. 
Iterator zwrócony przez *begin()* wskazuje na pierwszy element, podczas gdy iteratorzwrócony przez *end()* wskazuje na 
pozycję za ostatnim elementem kontenera.

```
int main() {
    vector<int> ar = { 1, 2, 3, 4, 5 };
      
    // Declaring iterator to a vector
    vector<int>::iterator ptr;
      
    // Displaying vector elements using begin() and end()
    cout << "The vector elements are : ";
    for (ptr = ar.begin(); ptr < ar.end(); ptr++)
        cout << *ptr << " ";
      
    return 0;    
}
```

**Output:**
>The vector elements are : 1 2 3 4 5

***Just in case: przeciążenie operatorów***
<a href="http://math.uni.lodz.pl/~cybula/psd/lec2.pdf">slajd 7+ (Cybula)</a> oraz <a href="http://math.uni.lodz.pl/~cybula/psd/lec2.pdf)](https://uniwersytetlodzki-my.sharepoint.com/:b:/g/personal/ul0238576_edu_uni_lodz_pl/EWASzeMxbjRKhf5iqSJw63EBS1bY2hcYST7KydrOng9eMA?e=6bYqWF">slajd 8+ (Wardowski)</a>.


**Selektory**

<ul>
<li>Za jego pomocą możemy wywoływać metody klasy dla obiektu</li>
<li>Jest on oznaczony za pomocą kropki</li>
<li>Przykład użycia selektora:

```
x.set(4, 4.5);
```
</li>
</ul>

**Zapytania**
<ul>
<li>Kwerendy utworzone w języku zapytań</li>
<li>Umożliwiają wyszukanie, tworzenie, usunięcie lub modyfikację danych
w bazie danych</li>
<li>Przykładem języka operującego na zapytaniach w bazach danych jest SQL (ang. Structured Query Language)

```
INSERT INTO TABLE osoby VALUES (’Jan’, ’Kowalski’);
SELECT imie FROM osoby WHERE nazwisko = ’Kowalski’;
UPDATE osoby SET imie = ’Adam’;
DELETE FROM osoby WHERE nazwisko = ’Kowalski’;
CREATE TABLE osoby (imie VARCHAR(50), nazwisko VARCHAR(50));
```
</li>
<li>Inne mniej popularne to np. QBE (ang. Query By Example) czy XQuery</li>
</ul>

## 19. Dziedziczenie i dynamiczny polimorfizm.

<a href="<link_to_resource_local_or_online_here>"></a><b></b>
<table align="center">
    <thead>
        <tr>
            <th>Ex. 1</th>
            <th>Ex. 2</th>
            <th>Ex. 3</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>Ts</td>
            <td>Ts</td>
            <td>Ts</td>
        </tr>
    </tbody>
</table>

## 20. Polimorfizm statyczny – szablony.

<a href="<link_to_resource_local_or_online_here>"></a><b></b>
<table align="center">
    <thead>
        <tr>
            <th>Ex. 1</th>
            <th>Ex. 2</th>
            <th>Ex. 3</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>Ts</td>
            <td>Ts</td>
            <td>Ts</td>
        </tr>
    </tbody>
</table>
